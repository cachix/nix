From e3b969ccf9226a9bd27ec59bcf1731c4dba76c14 Mon Sep 17 00:00:00 2001
From: Sander <hey@sandydoo.me>
Date: Tue, 12 Aug 2025 02:05:41 +0200
Subject: [PATCH] devenv: resolve physical path through impure mode union
 accessor

The issue:

1. Local directories are mounted at virtual store paths in the storeFS filesystem
2. When files are accessed through these mounts, they go through a
UnionSourceAccessor that sees the store paths
3. The original path information was lost in the process

We now keep track of the original store paths and provide a unified getPhysicalPath method to access them.
---
 src/libexpr/eval.cc                    | 54 +++++++++++++++++++++++++-
 src/libexpr/include/nix/expr/eval.hh   |  6 +++
 src/libexpr/primops.cc                 |  6 +--
 src/libutil/mounted-source-accessor.cc | 30 +++++++++++++-
 4 files changed, 91 insertions(+), 5 deletions(-)

diff --git a/src/libexpr/eval.cc b/src/libexpr/eval.cc
index 5d3e1e376..1219d3438 100644
--- a/src/libexpr/eval.cc
+++ b/src/libexpr/eval.cc
@@ -411,6 +411,58 @@ void EvalState::allowAndSetStorePathString(const StorePath & storePath, Value &
     mkStorePathString(storePath, v);
 }
 
+std::optional<std::filesystem::path> EvalState::getPhysicalPath(const SourcePath & path)
+{
+    // FIRST check if this is a store path that might be mounted
+    // This needs to happen before checking the direct physical path
+    // because in impure mode, the UnionSourceAccessor will return the actual
+    // /nix/store path as a physical path, but we want to resolve to the original mount
+
+    // Check if this path starts with the store directory
+    bool isStorePath = path.path.abs().starts_with(store->storeDir + "/");
+
+    if (isStorePath) {
+        // Extract just the store path part (without subpaths)
+        std::string pathStr = path.path.abs();
+        std::string storePrefix = store->storeDir + "/";
+        std::string relativePath = pathStr.substr(storePrefix.length());
+
+        // Find the end of the store path (next slash or end of string)
+        auto slashPos = relativePath.find('/');
+        std::string storePathName = slashPos != std::string::npos
+            ? relativePath.substr(0, slashPos)
+            : relativePath;
+
+        std::string fullStorePath = storePrefix + storePathName;
+
+        auto storePath = store->parseStorePath(fullStorePath);
+        auto mountPath = CanonPath(store->printStorePath(storePath));
+
+        if (auto mount = storeFS.dynamic_pointer_cast<MountedSourceAccessor>()) {
+            if (auto accessor = mount->getMount(mountPath)) {
+                // Get the relative path within the mount
+                std::string relPath;
+                if (slashPos != std::string::npos) {
+                    relPath = relativePath.substr(slashPos + 1);
+                }
+
+                // Try to get the physical path from the mounted accessor
+                auto mountPhysical = accessor->getPhysicalPath(CanonPath::root);
+                if (mountPhysical) {
+                    if (relPath.empty()) {
+                        return *mountPhysical;
+                    } else {
+                        return *mountPhysical / relPath;
+                    }
+                }
+            }
+        }
+    }
+
+    // If not a mounted store path, try the path's own physical path
+    return path.getPhysicalPath();
+}
+
 inline static bool isJustSchemePrefix(std::string_view prefix)
 {
     return
@@ -1123,7 +1175,7 @@ void EvalState::evalFile(const SourcePath & path, Value & v, bool mustBeTrivial)
         return;
     }
 
-    auto physicalPath = resolvedPath.getPhysicalPath();
+    auto physicalPath = getPhysicalPath(resolvedPath);
     printTalkative("evaluating file '%1%'", physicalPath ? physicalPath->string() : resolvedPath.to_string());
     Expr * e = nullptr;
 
diff --git a/src/libexpr/include/nix/expr/eval.hh b/src/libexpr/include/nix/expr/eval.hh
index 8ab2c3488..09b1d29ed 100644
--- a/src/libexpr/include/nix/expr/eval.hh
+++ b/src/libexpr/include/nix/expr/eval.hh
@@ -610,6 +610,12 @@ public:
      */
     std::string computeBaseName(const SourcePath & path);
 
+    /**
+     * Get the physical filesystem path for a SourcePath, if available.
+     * Returns the physical path if it exists, or attempts to resolve store paths.
+     */
+    std::optional<std::filesystem::path> getPhysicalPath(const SourcePath & path);
+
     /**
      * Path coercion.
      *
diff --git a/src/libexpr/primops.cc b/src/libexpr/primops.cc
index faed8be70..221267029 100644
--- a/src/libexpr/primops.cc
+++ b/src/libexpr/primops.cc
@@ -1773,7 +1773,7 @@ static void prim_pathExists(EvalState & state, const PosIdx pos, Value * * args,
             mustBeDir ? SymlinkResolution::Full : SymlinkResolution::Ancestors;
         auto path = realisePath(state, pos, arg, symlinkResolution);
 
-        auto physicalPath = path.getPhysicalPath();
+        auto physicalPath = state.getPhysicalPath(path);
         printTalkative("devenv pathExists: '%1%'", physicalPath ? physicalPath->string() : path.to_string());
 
         auto st = path.maybeLstat();
@@ -1876,7 +1876,7 @@ static RegisterPrimOp primop_dirOf({
 static void prim_readFile(EvalState & state, const PosIdx pos, Value * * args, Value & v)
 {
     auto path = realisePath(state, pos, *args[0]);
-    auto physicalPath = path.getPhysicalPath();
+    auto physicalPath = state.getPhysicalPath(path);
     printTalkative("devenv readFile: '%1%'", physicalPath ? physicalPath->string() : path.to_string());
     auto s = path.readFile();
     if (s.find((char) 0) != std::string::npos)
@@ -2146,7 +2146,7 @@ static RegisterPrimOp primop_readFileType({
 static void prim_readDir(EvalState & state, const PosIdx pos, Value * * args, Value & v)
 {
     auto path = realisePath(state, pos, *args[0]);
-    auto physicalPath = path.getPhysicalPath();
+    auto physicalPath = state.getPhysicalPath(path);
     printTalkative("devenv readDir: '%1%'", physicalPath ? physicalPath->string() : path.to_string());
 
     // Retrieve directory entries for all nodes in a directory.
diff --git a/src/libutil/mounted-source-accessor.cc b/src/libutil/mounted-source-accessor.cc
index 28e799e4c..3bdb49af9 100644
--- a/src/libutil/mounted-source-accessor.cc
+++ b/src/libutil/mounted-source-accessor.cc
@@ -5,6 +5,8 @@ namespace nix {
 struct MountedSourceAccessorImpl : MountedSourceAccessor
 {
     std::map<CanonPath, ref<SourceAccessor>> mounts;
+    // Track original paths for virtual store paths to enable proper path display
+    std::map<CanonPath, std::optional<std::filesystem::path>> originalPaths;
 
     MountedSourceAccessorImpl(std::map<CanonPath, ref<SourceAccessor>> _mounts)
         : mounts(std::move(_mounts))
@@ -72,14 +74,40 @@ struct MountedSourceAccessorImpl : MountedSourceAccessor
 
     std::optional<std::filesystem::path> getPhysicalPath(const CanonPath & path) override
     {
+        // First resolve which accessor and subpath we're dealing with
         auto [accessor, subpath] = resolve(path);
+
+        // Get the mount point for this accessor
+        for (const auto & [mountPoint, mountedAccessor] : mounts) {
+            if (mountedAccessor == accessor) {
+                // Check if we have an original path stored for this mount
+                auto it = originalPaths.find(mountPoint);
+                if (it != originalPaths.end() && it->second) {
+                    // Reconstruct the full path using the original path
+                    if (subpath.isRoot()) {
+                        return *it->second;
+                    } else {
+                        return *it->second / subpath.rel();
+                    }
+                }
+                break;
+            }
+        }
+
+        // Fallback to the accessor's own physical path
         return accessor->getPhysicalPath(subpath);
     }
 
     void mount(CanonPath mountPoint, ref<SourceAccessor> accessor) override
     {
         // FIXME: thread-safety
-        mounts.insert_or_assign(std::move(mountPoint), accessor);
+        mounts.insert_or_assign(mountPoint, accessor);
+
+        // Try to get the physical path from the accessor and store it
+        auto physicalPath = accessor->getPhysicalPath(CanonPath::root);
+        if (physicalPath) {
+            originalPaths[mountPoint] = physicalPath;
+        }
     }
 
     std::shared_ptr<SourceAccessor> getMount(CanonPath mountPoint) override
-- 
2.50.1

